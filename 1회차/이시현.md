# Item 1: 타입스크립트와 자바스크립트의 관계 이해하기

## 타입스크립트와 자바스크립트의 관계

- 타입스크립트는 자바스크립트의 상위집합(superset)
- 자바스크립트는 타입스크립트의 부분집합(subset)
<img width="612" alt="스크린샷 2025-01-23 오후 7 56 58" src="https://github.com/user-attachments/assets/a482fbe5-2f14-4d1b-88e8-2fe3c282d922" />

- 모든 자바스크립트 프로그램은 타입스크립트 프로그램이지만, 그 반대는 성립하지 않는다.
    - .js를 .ts로 변경해도 기능적 차이가 없다.
    - 기존 자바스크립트 코드의 점진적 마이그레이션이 용이하다.

## 타입스크립트의 타입 체크 기능

- 기본적인 타입 체크
    
    ```tsx
    let city = 'new york city';
    console.log(city.toUppercase());
                  // ~~~~~~~~~~~~ 'toUppercase' 속성이 'string' 형식에 없습니다.
                  //              'toUpperCase'를 사용하시겠습니까?
    ```
    
- 의도하지 않은 동작 감지
    
    ```tsx
    const states = [
      { name: 'Alabama', capital: 'Montgomery' },
      { name: 'Alaska', capital: 'Juneau' },
      { name: 'Arizona', capital: 'Phoenix' },
      // ...
    ]
    for (const state of states) {
      console.log(state.capitol)
    			       // ~~~~~~~~~~ 'capitol' 속성이 ... 형식에 없습니다. 
    			       //            'capital'을 사용하시겠습니까?
    }
    ```
    
- 구조적 타입 체크(타입 명시를 통해 의도를 분명히 하여 오류 예방)
    
    ```tsx
    interface State {
      name: string
      capital: string
    }
    const states: State[] = [
      { name: 'Alabama', capitol: 'Montgomery' },
      // ~~~~~~~~~~~~~~~~~~~~~
      { name: 'Alaska', capitol: 'Juneau' },
      // ~~~~~~~~~~~~~~~~~
      { name: 'Arizona', capitol: 'Phoenix' },
      // ~~~~~~~~~~~ 개체 리터럴은 알려진 속성만 지정할 수 있지만 
      //             'State' 형식에 'capitol'이 없습니다. 
    	//             'capital'을 쓰려고 했습니까?
      // ...
    ]
    ```
    
<img width="608" alt="스크린샷 2025-01-23 오후 7 57 18" src="https://github.com/user-attachments/assets/bcdde889-5342-4842-8aa9-cbd0a4b1324e" />

⇒ 모든 타입스크립트 프로그램이 타입 체커를 통과하는 것은 아니며, 타입 체커를 통과한 프로그램은 전체 타입스크립트 프로그램의 부분집합이라고 볼 수 있다.

## 타입 시스템의 동작 원리

- 자바스크립트 런타임 동작 모델링
    - 유연한 타입 변환
        
        ```tsx
        const x = 2 + '3';  // 정상, string 타입 "23"
        const y = '2' + 3;  // 정상, string 타입 "23"
        ```
        
- 의도치 않은 동작 방지
    - 자바스크립트에서는 실행되지만 타입스크립트는 방지
        
        ```tsx
        const a = null + 7;         // 자바스크립트에서는 a 값이 7이 됩니다.
        				// ~~~~ '+' 연산자를 ... 형식에 적용할 수 없습니다.
        const b = [] + 12;         // 자바스크립트에서는 b 값이 '12'가 됩니다.
        				// ~~~~~~~~ '+' 연산자를 ... 형식에 적용할 수 없습니다.
        alert('Hello', 'TypeScript');    // "Hello" 경고를 표시합니다.
        		  // ~~~~~ 0-1개의 인수가 필요한데 2개를 가져왔습니다.
        ```
        

## 타입 시스템의 한계와 주의사항

- 런타임 안정성의 한계
    - 타입 체크를 통과하더라도 런타임 오류가 발생하는 경우
        
        ```tsx
        const names = ['Alice', 'Bob'];
        console.log(names[2].toUpperCase());
        // TypeError: Cannot read property 'toUpperCase' of undefined
        ```
        
- 주의사항
    - 타입스크립트는 정적 타입의 완벽한 정확성을 보장하지는 않는다.
    - 타입시스템은 개발 단계의 오류 감지가 주 목적이다.
    - any 타입 사용 시 예상치 못한 오류가 발생할 수 있다.
    - 완벽한 타입 안정성이 필요하면 Reason, Elm 등을 선택하는 것이 좋다.
        - 단, 이러한 언어들은 자바스크립트의 상위 집합이 아니기 때문에 마이그레이션 과정이 훨씬 복잡하다.
<br/>


# Item 2: 타입스크립트 설정 이해하기

## 설정 파일의 중요성

- 타입스크립트는 많은 컴파일러 설정을 제공하며, 이는 커맨드 라인이나 tsconfig.json 파일을 통해 구성할 수 있다.
- 팀원들과 도구들이 프로젝트의 타입스크립트 설정을 쉽게 이해할 수 있도록 설정 파일을 사용하는 것이 권장된다.
- `tsc --init` 명령어로 기본 설정 파일을 생성할 수 있다.

## 핵심 컴파일러 설정

### noImplicitAny

- 모든 변수에 명시적인 타입 선언을 요구하는 설정이다.
- 설정이 해제되면 타입이 지정되지 않은 변수는 자동으로 any 타입으로 처리된다.
- 새 프로젝트에서는 이 설정을 활성화하는 것이 권장된다.
- 기존 자바스크립트 프로젝트를 마이그레이션할 때만 일시적으로 해제하는 것이 좋다.

### strictNullChecks

- null과 undefined가 다른 타입에 할당 가능한지를 제어하는 설정이다.
- 설정이 활성화되면 명시적으로 null과 undefined를 허용하는 타입을 선언해야 한다:
    
    ```tsx
    const x: number = null;
    // ~ 'null' 형식은 'number' 형식에 할당할 수 없습니다.
    
    const x: number | null = null;   
    // null을 허용하려면 의도를 명시적으로 드러냄으로써 오류를 고칠 수 있다.
    ```
    
- null 관련 런타임 오류를 방지하는 데 매우 효과적이다.
- 새 프로젝트에서는 가능한 한 초기에 설정하는 것이 좋다.
- noImplicitAny가 먼저 설정되어 있어야 활성화할 수 있다.
<br/>


# Item 3: 코드 생성과 타입이 관계없음을 이해하기

## **타입스크립트 컴파일러의 두 가지 역할**

1. 최신 타입스크립트/자바스크립트를 구버전 자바스크립트로 트랜스파일
2. 코드의 타입 오류 체크

이 두 가지 역할은 완전히 독립적! 

타입스크립트가 자바스크립트로 변환될 때, 자바스크립트 실행 시점에 타입은 영향을 미치지 않는다. 이는 타입스크립트 핵심 특성을 이해하는데 매우 중요하다.

## 타입 오류가 있는 코드도 컴파일이 가능하다

```tsx
let x = 'hello';
x = 1234;        // 타입 오류가 있지만 컴파일됨
```

- 컴파일과 타입 체크는 독립적으로 동작하기 때문에 타입 오류가 있는 코드도 컴파일이 가능하다.
- 타입스크립트 오류는 문제가 될 만한 부분을 알려주는 것이므로 빌드를 멈추지는 않는다.
- 이는 꼭 안 좋은 것은 아니다. 일부 코드에 오류가 있더라도 애플리케이션의 다른 부분을 테스트할 수 있게 해준다.
- 오류가 있을 때 컴파일을 막으려면 tsconfig.json에 `noEmitOnError` 설정을 사용할 수 있다.

## 런타임에는 타입 체크가 불가능하다

```tsx
interface Square {
  width: number;
}
interface Rectangle extends Square {
  height: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
									   // ~~~~~~~~~~~~ 'Rectangle'은 형식만 참조하지만,
									   //              여기서는 값으로 사용되고 있습니다.
    return shape.width * shape.height;
									   //        ~~~~~~~~ 'Shape' 형식에 'height' 속성이 없습니다.
  }
  ...
}
```

- 위 코드에서, instanceof 체크는 런타임에 일어나지만, Rectangle은 타입이기 때문에 런타임 시점에 아무런 역할을 하지 못한다.
- **타입스크립트의 타입은 제거 가능하다.**
- 즉, 자바스크립트로 컴파일 되는 과정에서 모든 인터페이스, 타입, 타입 구문이 제거된다.

### 런타임에 타입 정보를 유지하는 방법

- 속성의 존재 여부 체크
    - 속성 체크는 런타임에 접근 가능한 값에만 관련된다.
    
    ```tsx
    function calculateArea(shape: Shape) {
      if ('height' in shape) {
    	  shape;   // 타입이 Rectangle
        return shape.width * shape.height;
      } else {
    	  shape;   // 타입이 Square
    	  return shape.width * shape.width;
    	 }
    }
    ```
    
- 태그된 유니온 사용:
    - 런타임에 접근 가능한 타입 정보를 명시적으로 저장하여 해당 값을 통해 타입 정보를 유지한다.
    
    ```tsx
    interface Square {
      kind: 'square';  // 태그
      width: number;
    }
    interface Rectangle {
      kind: 'rectangle';  // 태그
      width: number;
      height: number;
    }
    type Shape = Square | Rectangle;
    
    function calculateArea(shape: Shape) {
      if (shape.kind === 'rectangle') {
    	  shape;   // 타입이 Rectangle
        return shape.width * shape.height;
      } else {
    	  shape;   // 타입이 Square
    	  return shape.width * shape.width;
    	 }
    }
    ```
    
- 클래스를 이용한 타입 선언:
    - 타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘 다 사용하는 기법
    - 인터페이스는 타입으로만 사용 가능하지만, Rectangle을 클래스로 선언하면 타입과 값 모두 사용할 수 있다.
    
    ```tsx
    class Square {
      constructor(public width: number) {}
    }
    class Rectangle extends Square {
      constructor(public width: number, public height: number) {
        super(width);
      }
    }
    type Shape = Square | Rectangle;      // 타입으로 참조
    
    function calculateArea(shape: Shape) {
      if (shape instanceof Rectangle) {       // 값으로 참조
        shape; // 타입이 Rectangle
        return shape.width * shape.height;
      } else {
        shape; // 타입이 Square
        return shape.width * shape.width; // OK
      }
    }
    ```
    

## 타입 연산은 런타임에 영향을 주지 않는다

- 예시: string 또는 number 타입인 값을 항상 number로 정제하는 경우
    
    ```tsx
    // 타입 체커를 통과하지만 잘못된 방법 
    function asNumber(val: number | string): number {
    	return val as number;
    }
    
    // 변환된 자바스크립트 코드
    function asNumber(val) {
    	return val;
    }
    ```
    
    - 변환된 자바스크립트 코드를 보면 아무런 정제 과정이 없다.
    - as number는 타입 연산이고 런타임 동작에는 아무런 영향을 미치지 않는다.
    - 값을 정제하기 위해서는 **런타임의 타입을 체크**해야 하고 **자바스크립트 연산을 통해 변환을 수행**해야 한다.
    
    ```tsx
    function asNumber(val: number | string): number {
    	return typeof(val) === 'string' ? Number(val) : val;
    }
    ```
    

## 런타임 타입은 선언된 타입과 다를 수 있다

- 예시: 조명 스위치 제어함수
    
    ```tsx
    function setLightSwitch(value: boolean) {
      switch (value) {
        case true:
          turnLightOn();
          break;
        case false:
          turnLightOff();
          break;
        default:
          console.log(`실행되지 않을까 봐 걱정됩니다.`);
      }
    }
    ```
    
    - 위 코드에서 `: boolean` 이 타입 선언문이기 때문에 런타임에 제거된다.
    - 만약, 네트워크 호출로부터 받아온 값으로 함수를 실행하는 경우
        - 요청의 결과로 boolean 값을 반환하라고 선언하더라도 실제로 그렇게 되리라는 보장이 없다.
        - 서버 오류나 API 변경 사항이 제대로 반영되지 않은 경우가 있을 수 있다.
        - 따라서, 외부 데이터를 다룰 땐 항상 런타임에서의 타입 불일치 가능성을 고려해야 한다.
    

## 타입스크립트 타입으로는 함수를 오버로드할 수 없다

- 타입과 런타임의 동작이 무관하므로, 타입스크립트는 함수 오버로딩이 불가하다.
- 그러나, 타입스크립트가 함수 오버로딩 기능을 지원하기는 한다.
- 타입스크립트의 함수 오버로딩
    - 선언부(오버로드 시그니처)와 구현부(구현 시그니처)로 나뉜다.
        - 선언부: 매개변수의 타입 지정
        - 구현부: 함수 구현
    - 하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만, 구현체는 오직 하나뿐이다.

```tsx
// 선언부
function add(a: number, b: number): number;
function add(a: string, b: string): string;

// 구현부
function add(a, b) {
	return a + b;
}

const three = add(1, 2);       // 타입이 number
const twelve = add('1', '2');  // 타입이 string
```

## 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에, 런타임의 성능에 아무런 영향을 주지 않는다.
    
    ⇒ 타입스크립트 컴파일러는 런타임 오버헤드가 없다.
    
- 대신, 빌드타입 오버헤드가 있다.
<br/>


# Item 4: 구조적 타이핑에 익숙해지기

## 구조적 타이핑의 기본 개념

> 덕 타이핑: 만약 어떤 새가 오리처럼 걷고 헤엄치고 꽥꽥 거린다면 나는 그 새를 오리라고 부를 것이다.
⇒ 객체가 어떤 타입에 부합하는 변수와 메소드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식
> 
- 타입스크립트는 자바스크립트의 덕 타이핑을 모델링하여 구조적 타이핑을 구현한다.
- **즉, 타입 간의 관계를 명시적으로 선언하지 않아도, 구조가 호환되면 할당이 가능하다.**
- 구조적 타이핑의 실제 동작 예시:
    
    ```tsx
    // 2D 벡터 타입
    interface Vector2D {
    	x: number;
    	y: number;
    }
    
    // 벡터의 길이를 계산하는 함수
    function calculateLength(v: Vector2D) {
    	return Math.sqrt(v.x * v.x + v.y * v.y);
    }
    
    // 이름이 들어간 벡터
    interface NamedVector {
    	name: string;
    	x: number;
    	y: number;
    }
    
    // NamedVector는 x, y를 포함하므로 Vector2D와 호환됨
    const v: NamedVector = { x: 3, y: 4, name: 'Zee' };
    calculateLength(v); // 정상, 결과는 5
    ```
    
    - `Vector2D` 와 `NamedVector` 의 관계를 전혀 선언하지 않았다.
    - `NamedVector` 를 위한 별도의 `calculateLength`를 구현하지 않았다.
    
    ⇒ `NamedVector` 의 구조가 `Vector2D` 와 호환되기 때문에 `calculateLength` 호출이 가능하다.
    

## 구조적 타이핑때문에 일어날 수 있는 문제점

- 예시: 3D 벡터
    
    ```tsx
    // 3D 벡터 타입
    interface Vector3D {
      x: number;
      y: number;
      z: number;
    }
    
    // 벡터의 길이를 1로 만드는 정규화 함수
    function normalize(v: Vector3D) {
      const length = calculateLength(v); // Vector2D 함수를 Vector3D에 사용
      return {
        x: v.x / length,
        y: v.y / length,
        z: v.z / length,
      };
    }
    ```
    
    - Vector3D는 x, y를 포함하므로 Vector2D와 호환된다.
    - 하지만 이는 `z`값이 정규화 계산에서 무시되는 버그를 발생시킨다.
    - Vector2D, Vector3D에서 볼 수 있듯이 타입스크립트는 객체가 필요한 속성만 가지고 있다면 다른 추가 속성이 있어도 타입이 호환된다고 판단한다.
        - 이를 “열린 타입(open type)” 시스템이라고 부른다.
        - 타입스크립트는 봉인된(sealed) 또는 정확한(precise) 타입을 표현할 수 없다.
- `Object.keys()`를 사용한 객체 순회시 주의사항
    
    ```tsx
    function calculateLengthL1(v: Vector3D) {
      for (const axis of Object.keys(v)) {
        const coord = v[axis]  // 오류 발생
        length += Math.abs(coord)
      }
    }
    
    const vec3D = { x: 3, y: 4, z: 1, address: '123 Broadway' };
    calculateLengthL1(vec3D); // // Vector3D 타입이 예상되는 곳에 추가 속성이 있는 객체도 할당 가능
    ```
    
    - 구조적 타이핑으로 인해 추가 속성이 있을 수 있어서 타입 안정성이 보장되지 않는다.
    - 이런 경우 객체를 순회하는 것보단 각 속성을 명시적으로 접근하는 것이 더 안전하다.
- 클래스와 구조적 타이핑
    
    ```tsx
    class C {
      foo: string;
      constructor(foo: string) {
        this.foo = foo;
      }
    }
    const d: C = { foo: 'object literal' };  // 정상
    ```
    
    - 필요한 속성과 구조만 일치하면 클래스의 인스턴스가 아니어도 타입 호환된다.
    - 다만 C의 생성자에 단순 할당이 아닌 연산 로직이 존재한다면, 즉 생성자의 로직이 중요한 경우 문제가 될 수 있다.
<br/>


# Item 5: any 타입 지양하기

## any 타입에는 타입 안전성이 없다

```tsx
let age: number;
age = '12' as any;  // 문자열을 숫자 타입 변수에 할당
age += 1;   // 런타임에는 "121"이 됨
```

- any를 사용하면 타입 체커의 보호를 받지 못한다.
- age는 number 타입으로 선언되었지만, any 타입 단언으로 인해 string을 할당 할 수 있게 되어 예기치 않은 런타임 동작이 발생한다.

## any는 함수 시그니처를 무시해 버린다

- 함수를 작성할 땐 시그니처를 명시해야 한다.
- 호출하는 쪽은 약속된 타입의 입력을 제공하고 함수는 약속된 타입의 출력을 반환한다.
- 그러나, any를 사용하면 아래 코드에서처럼 함수 시그니처를 무시하여 오류가 발생할 수 있다.

```tsx
function calculateAge(birthDate: Date): number {
    // ... 
}

let birthDate: any = '1990-01-19';
calculateAge(birthDate);  // 타입 체커가 통과시키지만 런타임 오류 발생 가능
```

## any 타입에는 언어 서비스가 적용되지 않는다

- any 타입을 사용하면 자동 완성 기능, 도움말, 심볼 이름 변경 등 리팩토링 기능을 사용할 수 없다.

```tsx
interface Person {
    firstName: string;
    last: string;
}

const formatName = (p: Person) => `${p.firstName} ${p.last}`;
const formatNameAny = (p: any) => `${p.first} ${p.last}`;
// formatNameAny에서는 first를 firstName으로 일괄 변경 불가
```

## 그 외 any 타입을 쓰면 안 되는 이유

- any 타입은 코드 리팩터링 때 버그를 감춘다.
- any는 타입 설계를 감춘다.
- any는 타입시스템의 신뢰도를 떨어뜨린다.

⇒ 어쩔 수 없이 any를 써야하는 상황(에 대해서는 5장에서 다룬다.)을 제외하곤 any를 지양하자! 
<br/>


# Item 6: 편집기를 사용하여 타입 시스템 탐색하기

> 타입스크립트의 가장 중요한 역할은 **타입 시스템에 있다.**
> 

- 타입 스크립트를 설치하면 다음 두 가지를 실행할 수 있다.
    - 타입스크립트 컴파일러(tsc)
    - 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)
- 보통은 타입스크립트 컴파일러를 실행하는 것이 주된 목적이지만, 타입스크립트 서버 또한 ‘언어 서비스’를 제공한다는 점에서 중요하다.

## 언어 서비스

- 언어 서비스: 코드 자동완성, 명세(specification) 검사, 검색, 리팩터링
- 보통은 편집기를 통해 언어서비스를 사용하는데, 타입스크립트 서버에서 언어 서비스를 제공하도록 설정하는게 좋다.

## 편집기의 역할과 중요성

- 편집기는 타입스크립트가 언제 타입 추론을 수행할 수 있는지에 대한 개념을 잡게 해주는데, 이 개념을 확실히 잡아야 간결하고 읽기 쉬운 코드를 작성할 수 있다.
- 편집기를 통해 타입스크립트가 그 타입을 어떻게 판단하고 있는지 확인하는 것은 타입 넓히기와 좁히기의 개념을 잡기 위해 꼭 필요한 과정이다.
- 조건문의 분기에서 값의 타입이 어떻게 변하는지 살펴보는 것은 타입시스템을 연마하는 매우 좋은 방법이다.
- 객체에서는 개별 속성을 살펴봄으로써 타입 스크립트가 어떻게 각각의 속성을 추론하는지 살펴볼 수 있다.
- 편집기 상의 타입 오류를 살펴보는 것도 타입 시스템의 성향을 파악하는데 좋은 방법이다.
- 언어 서비스는 라이브러리와 라이브러리의 타입 선언을 탐색할 때 도움이 된다.
    - ‘Go to Definition(정의로 이동)’ 옵션을 통해 타입스크립트에 포함되어 있는 DOM 타입 선언인 lib.dom.d.ts로 이동하여 타입을 탐색할 수 있다.

**결론:** 이런식으로 타입 선언은 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링 되었는지, 어떻게 오류를 찾아낼지에 대해 살펴볼 수 있는 훌륭한 수단이다.
<br/>


# Item 7: 타입이 값들의 집합이라고 생각하기

## 타입의 기본 개념

- 런타임에 각 변수는 하나의 값을 가진다.
- 그러나, 코드가 실행되기 전, 타입스크립트가 오류를 체크하는 컴파일 타임에 각 변수는 ‘할당 가능한 값들의 집합’인 타입을 가진다.
    - 예) number 타입은 모든 숫자값들의 집합
    - 예) string 타입은 모든 문자열값들의 집합

### 타입의 크기 (범위)

1. never 타입 (가장 작은 집합)
    - 공집합과 같다.
    - 어떤 값도 할당할 수 없다.
    
    ```tsx
    let x: never = 12;   // 불가능
    ```
    
2. 리터럴 타입 (단일 값 집합)
    - 유닛 타입이라고도 한다.
    
    ```tsx
    type A = 'A';     // 오직 'A'라는 값만 가능
    type Twelve = 12; // 오직 12라는 값만 가능
    ```
    
3. 유니온 타입 (여러 값의 합집합)
    
    ```tsx
    type AB = 'A' | 'B';   // ‘A’ 또는 ‘B’ 가능
    type AB12 = 'A' | 'B' | 12;   // ‘A’ 또는 ‘B’ 또는 12 가능
    ```
    

## 타입 관계 이해

### 할당 가능성

```tsx
type AB = 'A' | 'B';
const a: AB = 'A';  // 가능: 'A'는 AB 집합의 원소
const c: AB = 'C';  // 불가능: 'C'는 AB 집합의 원소가 아님
```

### 인터페이스와 집합

```tsx
interface Person {
	name: string;
}
```

- Person 타입은 “string 타입의 name 속성을 가진 모든 객체들의 집합”
- 추가 속성도 가질 수 있다! (구조적 타이핑)

### 교집합(&)과 합집합(|)

```tsx
interface Person { name: string; }
interface Lifespan { birth: Date; death?: Date; }
type PersonSpan = Person & Lifespan;
```

- 교집합(&)은 두 타입의 모든 속성을 포함해야 한다.
- 타입 연산자는 인터페이스의 속성이 아닌, 값의 집합(타입의 범위)에 적용된다.
- 위 예시에서 PersonSpan은 문자열 name, Date타입의 birth, Date타입의 death(선택) 속성을 모두 가져야 한다.

## 상속과 서브타입

### 서브타입

```tsx
interface Vector1D { x: number; } 
interface Vector2D extends Vector1D { y: number; } 
interface Vector3D extends Vector2D { z: number; }
```

- 서브타입은 어떤 집합이 다른 집합의 부분 집합이라는 의미이다.
- Vector3D는 Vector2D의 서브타입이고 Vector2D는 Vector1D의 서브타입이다.
    - **구조적 타이핑**의 관점에서, 더 많은 속성을 가진 타입이 서브타입이 된다.
    - 서브타입은 “더 구체적인” 타입이다. 상위 타입의 모든 특성을 포함하면서 추가 특성을 가진다.
    
    <img width="597" alt="스크린샷 2025-01-23 오후 7 59 24" src="https://github.com/user-attachments/assets/1d981555-d62e-4936-ae4c-a32c7f14562d" />


### 제너릭에서의 extends

```tsx
function getKey<K extends string>(val: any, key: K)
```

- extends 키워드는 제너릭타입에서 한정자로도 쓰이며, ‘~의 부분 집합’을 의미하기도 한다.
- K는 string 타입의 부분집합이어야 한다.
    - string 리터럴 타입, string 리터럴 타입의 유니온, string 자신을 포함한다.
<img width="513" alt="스크린샷 2025-01-23 오후 7 59 40" src="https://github.com/user-attachments/assets/5fc190e1-d987-4232-aeda-3e3954caef94" />

<br/>



# Item 8: 타입 공간과 값 공간의 심벌 구분하기

## 타입 공간과 값 공간의 개념

- 타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중 한 곳에 존재한다.
- 동일한 이름의 심벌이라도 속한 공간에 따라 다른 의미를 가질 수 있다.
    
    ```tsx
    interface Cylinder {
    	radius: number;
    	height: number;
    }
    
    const Cylinder = (radius: number, height: number) => ({radius, height});
    ```
    
    - interface Cylinder와 const Cylinder는 각각 타입과 값으로 쓰이며 서로 아무런 관련도 없다.
    - 이런 점이 아래와 같은 오류를 야기할 수 있다.
    
    ```tsx
    function calculateVolume(shape: unknown) {
    	if (shape instanceof Cylinder) {
    		shape.radius;
    			// ~~~ '{}' 형식에 'radius' 속성이 없습니다.
    	}
    }		
    ```
    
    - `instanceof` 는 자바스크립트의 런타임 연산자이고 값에 대해 연산을 한다. 그래서 `instanceof Cylinder`는 타입이 아니라 함수를 참조한다.
- 한 심벌이 타입인지 값인지는 문맥을 살펴 알아내야 한다.
- 타입스크립트 플레이그라운드는 타입스크립트 소스로부터 변환된 자바스크립트 코드를 보여준다.
    - 컴파일 과정에서 타입 정보는 제거되므로 변환된 자바스크립트 코드를 보면 어떤 것이 타입이었는지 알 수 있다.

## 심벌 구분 방법

- type, interface 뒤에 오는 심벌은 타입으로 사용한다.
- const, let 선언에 사용되는 것은 값으로 사용한다.
- 타입 선언(:) 또는 단언문(as) 뒤에 오는 심벌은 타입이다.
- = 뒤에 오는 모든 것은 값이다.
- class와 enum은 상황에 따라 타입과 값 모두 가능하다.

## typeof 연산자의 두 가지 기능

```tsx
type T1 = typeof P;   // 타입은 Person
type T2 = typeof email;
			// 타입은 (p: Person, subject: string, body: string) => Response
const v1 = typeof p;   // 값은 "object"
const v2 = typeof email;   // 값은 "function"
```

- **타입의 관점**에서 typeof는 값을 읽어서 타입스크립트 타입을 반환한다.
- **값의 관점**에서 typeof는 자바스크립트 런타임의 typeof 연산자로 작동하며, 기본적인 6가지 런타임 타입(string, number, boolean, undefined, object, function) 중 하나를 반환한다.

### 이외 주요 연산자와 키워드의 공간별 차이점

- this: 값으로는 자바스크립트의 this, 타입으로는 다형성 this
- &와 |: 값에서는 비트 연산자, 타입에서는 인터섹션과 유니온
- const vs as const: 변수 선언 vs 리터럴 타입 추론 변경
- extends: 서브클래스, 서브타입, 제너릭 타입의 한정자로 사용
- in: 루프 또는 매핑된 타입에서 사용

# Item 9: 타입 단언보다는 타입 선언을 사용하기

## 변수에 타입을 부여하는 방법

```tsx
const alice: Person = { name: 'Alice' };
const bob = { name: 'Bob' } as Person;
```

- 첫 번째 방법은 **‘타입 선언’**을 붙여 그 값이 선언된 타입임을 명시한 것이다.
- 두 번째 방법은 **‘타입 단언’**으로 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.

⇒ 타입 단언보다 타입 선언을 사용하는 게 낫다.

## 타입 선언이 나은 이유

- 타입 체크에서의 안전성
    - 타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.
    - 반면, 타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.
- 속성을 추가하는 경우
    - 타입 선언문에서는 잉여 속성 체크가 동작하지만, 단언문에서는 적용되지 않는다.

## 화살표 함수에서의 타입 선언

- 화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있다.
- 이 문제를 타입 단언으로 해결할 수도 있지만 앞서 설명했듯 타입 단언은 런타임 문제가 발생할 수 있다.
- 아래와 같은 방법을 쓰는 것이 좋다.

```tsx
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
);    // 타입은 Person[] 
```

- (name): Person은 name의 타입이 없고, 반환 타입이 Person이라고 명시한다.

## 타입 단언이 꼭 필요한 경우

- 타입 단언은 타입 체커가 추론한 타입보다 직접 판단하는 타입이 더 정확할 때 의미가 있다.
- 타입스크립트가 알지 못하는 정보를 가지고 있을 때는 타입 단언문을 쓰는 게 낫다.
- 아님을 나타낼 때 쓰는 특별한 문법인 !도 단언문처럼 생각해야 한다.
    - 따라서 그 값이 null이 아님을 확신할 수 있을때만 !null을 사용해야 한다.
<br/>


# Item 10: 객체 래퍼 타입 피하기

## 기본형과 객체 래퍼 타입의 차이점

- JavaScript의 기본형 타입(string, number, boolean, null, undefined, symbol, bigint)는 불변성을 가지며 메서드가 없다.
- 그러나 기본형인 string의 경우 메서드를 가지고 있는 것처럼 보인다. 이는 JavaScript가 자동으로 객체 래퍼 타입(e.g. String 객체)으로 변환하기 때문이다.

```bash
> 'primitive'.charAt(3)
"m"
```

- 위 예시는 내부적으로 다음 과정을 거친다:
    - 기본형 문자열을 임시 String 객체로 래핑
    - charAt 메서드 호출
    - 메서드 호출 후, 생성된 임시 String 객체는 버림

### 몽키 패치로 객체 래퍼 동작 이해

> 몽키 패치(monkey-patch): 런타임에 프로그램의 어떤 기능을 수정해서 사용하는 기법. JS에서는 주로 프로토타입을 런타임에 수정하는 기법이 해당된다.
> 

```jsx
// String.prototype.charAt 의 원본 메서드를 보관
const originalCharAt = String.prototype.charAt;

// charAt 메서드를 새로운 구현으로 교체
String.prototype.charAt = function(pos) { 
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
};

// 기본형 문자열에서 charAt 호출
console.log('primitive'.charAt(3));
```

- 위 코드는 다음을 출력한다.
    
    ```jsx
    [String: 'primitive'] 'object' 3
    m
    ```
    
    - `this` 의 타입이 ‘object’인 것으로 보아, 기본형 문자열이 실제로 String 객체로 래핑되었음을 확인 가능하다.
    - 콘솔에 출력된 `[String: 'primitive']`는 JavaScript가 생성한 임시 String 객체를 나타낸다.

## 기본형과 객체 래퍼의 주의할 점

- 기본형과 객체 래퍼는 항상 동일하게 동작하는 것은 아니다.
- 기본형과 객체 래퍼는 동일하지 않으며, String 객체는 오직 자기 자신하고만 동일하다:
    
    ```jsx
    "hello" === new String("hello"); // false
    new String("hello") === new String("hello"); // false
    ```
    
- 기본형에 속성을 추가하면, 추가된 객체가 즉시 버려진다.
    
    ```jsx
    x = "hello";
    x.language = "English";    // 임시 객체에 속성이 추가됨
    x.language;   // undefined - 임시 객체는 이미 버려짐
    ```
    
    - 실제로는 x가 String의 객체로 변환된 후 language 속성이 추가되었고, language 속성이 추가된 객체는 버려진 것이다.

## TypeScript에서의 객체 래퍼 타입 사용

- TypeScript는 기본형과 객체 래퍼 타입을 별도로 모델링한다(=명확하게 구분한다):
- `string` 을 `String` 으로 잘못 타이핑 하더라도 처음에는 잘 동작하는 것처럼 보이기 때문에 유의해야한다.
- 그러나, `string` 을 매개변수로 받는 메서드에 `String` 객체를 전달하면 문제가 발생한다.
- `string` 은 `String` 에 할당할 수 있지만, `String` 은 `string` 에 할당할 수 없다.

- TypeScript의 타입 선언은 기본형 타입을 따른다. 따라서 객체 래퍼 타입을 사용하지 않는 것이 좋다.
    
    ```tsx
    const s: String = "primitive"; // 비권장
    const n: Number = 12;         // 비권장
    ```
    
    - 위와 같은 선언에서도 런타임의 값은 객체가 아니고 기본형이다.
    - 기본형 타입은 객체 래퍼에 할당할 수 있기 때문에, 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 선언을 허용하긴 하지만, 이는 불필요한 복잡성을 초래할 수 있기 때문에 그냥 기본형을 쓰는 것이 낫다.
- 그러나, 예외로 `new` 없이 `BigInt` 와 `Symbol` 을 호출하는 경우는 기본형을 생성하기 때문에 사용해도 좋다.
    
    ```tsx
    typeof BigInt(1234); // "bigint"
    typeof Symbol('sym'); // "symbol"
    ```
    
<br/>


# Item 11: 잉여 속성 체크의 한계 인지하기

## 잉여 속성 체크란?

- 타입이 명시된 변수에 객체 리터럴을 특정 타입에 할당할 때, 타입스크립트는 해당 타입에 정의되지 않은 추가 속성이 있는지 검사한다. 이를 잉여 속성 체크라고 한다.
    
    ```tsx
    interface Room {
        numDoors: number;
        ceilingHeightFt: number;
    }
    
    // 오류: 'elephant' 속성은 Room 타입에 없음
    const room: Room = {
        numDoors: 1,
        ceilingHeightFt: 10,
        elephant: 'present'  
    };
    ```
    

- 잉여 속성 체크 검사가 항상 동작하는 것은 아니다. 예를 들어, **임시 변수(중간 변수)를 사용하면 검사를 우회**할 수 있다.
    
    ```tsx
    const obj = { numDoors: 1, ceilingHeightFt: 10, elephant: 'present' };
    const room: Room = obj;  // 정상 동작
    ```
    
    - 위와 같은 경우가 가능한 이유는 **TypeScript가 구조적 타이핑을 사용**하기 때문이다.
    - obj 타입은 Room 타입의 부분 집합을 포함하므로, 즉 Room 타입이 필요로 하는 모든 속성을 가지고 있으므로 추가 속성이 있더라도 Room에 할당 가능하며 타입 체커도 통과한다.

## 잉여 속성 체크의 우회 방법

잉여 속성 체크를 의도적으로 우회해야 할 필요가 있을 때는 아래의 방법을 사용하면 된다.

- 타입 단언(Type Assertion) 사용:
    - `as` 를 사용하면 TypeScript는 잉여 속성 체크를 건너뛰고 강제로 타입을 적용한다.
    
    ```tsx
    interface Options {
        darkMode?: boolean;
        title?: string;
    }
    
    // 타입 단언을 사용하면 체크를 우회
    const o = { darkMode: true, extraOption: true } as Options;   // 정상
    ```
    

- 인덱스 시그니처 사용:
    - 객체에 정의되지 않은 속성을 허용하려면 인덱스 시그니처를 사용할 수 있다.
    
    ```tsx
    interface Options {
        darkMode?: boolean;
        [otherOptions: string]: unknown;  // 추가 속성 허용
    }
    
    // 추가 속성이 있어도 오류가 발생하지 않음
    const options: Options = {
        darkMode: true,
        extraOption: "whatever"
    };
    ```
    

## 약한 타입과 공통 속성 체크

- 약한 타입은 모든 속성이 선택적(optional)인 타입이다.
- 따라서 어떤 객체든 할당할 수 있지만, 공통 속성 체크라는 별도 검사가 수행된다.
    
    ```tsx
    interface LineChartOptions {
        logscale?: boolean;
        invertedYAxis?: boolean;
        areaChart?: boolean;
    }
    
    const opts = { logScale: true };
    const op: LineChartOptions = opts;
    // 오류: 'LineChartOptions'에 공통 속성이 없음
    ```
    
    - 구조적 관점에서 `LineChartOptions` 은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다.
    - 그러나, 공통 속성 체크에 의해 `opts` 객체가 `LineChartOptions` 의 어떤 속성과도 이름이 일치하지 않기 때문에 오류가 발생한다.
    - 잉여 속성과 마찬가지로 오타를 잡는 데 효과적이며 구조적으로 엄격하지 않다.

# Item 12: 함수 표현식에 타입 적용하기

## 함수 문장과 함수 표현식의 차이

- 자바스크립트(,타입스크립트)에서는 함수 문장(statement)과 함수 표현식(expression)을 다르게 인식한다.
    
    ```tsx
    // 문장 (함수 선언문; 독립적으로 정의된 함수로 코드가 실행되기 전에 메모리에 로드되므로 어디서든 호출 가능)
    function rollDice1(sides: number): number {
        return Math.floor(Math.random() * sides) + 1;
    }
    
    // 표현식 (함수 자체를 변수에 할당하여 정의하는 방식. 함수가 할당된 후에만 호출 가능)
    const rollDice2 = function (sides: number): number {
        return Math.floor(Math.random() * sides) + 1;
    };
    
    // 표현식 (화살표 함수; 함수 표현식을 좀 더 간결하게 작성)
    const rollDice3 = (sides: number): number => Math.floor(Math.random() * sides) + 1;
    
    ```
    

## 함수 표현식의 장점

- **타입 재사용성**
    - 함수 매개변수부터 반환값까지 전체를 함수 타입으로 선언(⇒ 함수 타입 선언)하여 함수 표현식에 재사용할 수 있다.
    
    ```tsx
    // 주사위 굴리기 함수 타입 정의
    type DiceRollFn = (sides: number) => number;
    
    // 다른 구현에서 동일한 타입 재사용
    const rollDice: DiceRollFn = sides => Math.floor(Math.random() * sides) + 1;
    ```
    

## 함수 타입 선언의 필요성

- 코드 중복 제거 및 가독성 향상
    
    ```tsx
    // 중복된 함수 선언
    function add(a: number, b: number): number { return a + b; }
    function sub(a: number, b: number): number { return a - b; }
    function mul(a: number, b: number): number { return a * b; }
    function div(a: number, b: number): number { return a / b; }
    ```
    
    위 반복되는 함수 시그니처를 아래 코드처럼 하나의 함수 타입으로 통합할 수 있다.
    
    ```tsx
    type BinaryFn = (a: number, b: number) => number;
    
    const add: BinaryFn = (a, b) => a + b;
    const sub: BinaryFn = (a, b) => a - b;
    const mul: BinaryFn = (a, b) => a * b;
    const div: BinaryFn = (a, b) => a / b;
    ```
    

## 라이브러리에서의 함수 타입 활용

- React 같은 라이브러리들은 자주 사용되는 함수의 타입을 미리 정의해서 제공하기도 한다. 
(= 공통 함수 시그니처를 타입으로 제공하기도 한다.)
    
    ```tsx
    // 일반적인 방식 - 함수 매개변수에 타입 지정
    const handleClick = (event: MouseEvent) => { /* ... */ };
    
    // React 방식 - 함수 전체에 타입 지정
    const handleClick: MouseEventHandler = (event) => { /* ... */ };
    ```
    

## 실제 예시: fetch 함수에 타입 적용하기

- 시그니처가 일치하는 다른 함수가 있을 때도 함수 표현식에 타입을 적용해볼 수 있다.
- 예를 들어, 웹 브라우저에서 fetch 함수는 특정 리소스에 HTTP 요청을 보낸다.
    
    ```tsx
    const responseP = fetch('/quote?by=Mark+Twain');  // 반환 타입이 Promise<Response>
    ```
    
- 그리고 reponse.json() 또는 response.text()를 사용해 응답 데이터를 추출한다.
    
    ```tsx
    async function getQuote() {
        const response = await fetch('/quote?by=Mark+Twain');
        const quote = await response.json();
        return quote;
    }
    ```
    
    - 여기에는 두 가지 문제가 있다.
        1. API가 없을 때(404 에러)도 fetch는 정상적으로 응답을 반환한다.
        2. 서버가 JSON이 아닌 응답을 보내면 실제 오류(404)가 아닌 JSON 파싱 오류가 발생한다.
    

### 개선된 버전: checkedFetch

- 첫 번째 방법: 매개변수에 타입 지정
    
    ```tsx
    async function checkedFetch(input: RequestInfo, init?: RequestInit) {
        const response = await fetch(input, init);
        if (!response.ok) {
            throw new Error('Request failed: ' + response.status);
        }
        return response;
    }
    ```
    

- 두 번째 방법: typeof를 활용한 함수 전체 타입 지정
    
    > `typeof fetch` : 브라우저에 내장된 함수인 `fetch` 의 타입을 `typeof` 로 그대로 가져와 사용하는 것
    > 
    
    ```tsx
    const checkedFetch: typeof fetch = async (input, init) => {
        const response = await fetch(input, init);
        // response.ok가 false인 경우(404, 500 등의 HTTP 에러)
        if (!response.ok) {
            throw new Error('Request failed: ' + response.status);
        }
        return response;
    };
    ```
    
    - 함수 문장을 함수 표현식으로 변경하였고 함수 전체에 타입(typeof fetch)을 적용하였다.
        - 타입스크립트가 input과 init의 타입을 추론할 수 있게 해준다.
        - 반환 타입이 원본 fetch와 동일함을 보장한다.
        - 오류 발생 시 타입스크립트가 이를 감지하여 코드의 안정성을 높인다.
            
            ```tsx
            const checkedFetch: typeof fetch = async (input, init) => {
                const response = await fetch(input, init);
                if (!response.ok) {
                    ***return*** new Error('Request failed: ' + response.status); // 타입 에러!
                }
                return response;
            };
            ```
            
            - 위 코드는 throw가 아닌 return 을 사용하였다.
            - typeof fetch는 항상 Promise<Response>를 반환해야 하는데, Error 객체를 반환하려고 시도했기 때문에 타입 에러가 발생한다.

### 정리

- 라이브러리 개발 시 자주 사용되는 콜백 함수의 타입을 미리 정의해 제공한다.
- 매개변수마다 타입을 지정하는 것보다 함수 전체의 타입을 한 번에 지정하는 것이 효율적이다.
- 기존 함수의 타입을 재사용할 때는 `typeof` 를 활용하면 더 편리하고 타입 안정성을 보장받을 수 있다.

# Item 13: 타입과 인터페이스의 차이점 알기

## 타입과 인터페이스의 공통점

- 기본적인 객체 타입을 정의할 수 있다.
    
    ```tsx
    type TState = { name: string; capital: string };
    interface IState { name: string; capital: string }
    ```
    
- 인덱스 시그니처를 사용할 수 있다. (동적인 키를 가진 객체를 정의할 때 둘 다 사용 가능)
    
    ```tsx
    type TDict = { [key: string]: string };
    interface IDict { [key: string]: string }
    ```
    
- 함수 타입을 정의할 수 있다.
    
    ```tsx
    type TFn = (x: number) => string;
    interface IFn {
      (x: number): string;
    }
    
    const toStr1: TFn = x => '' + x;
    const toStr2: IFn = x => '' + x;
    ```
    
- 제네릭을 지원한다.
    
    ```tsx
    type TPair<T> = { first: T; second: T };
    interface IPair<T> { first: T; second: T }
    ```
    

## 타입과 인터페이스의 차이점

1. 유니온 타입
    - 타입은 유니온 타입을 만들 수 있지만, 인터페이스는 유니온 타입을 직접 만들 수 없다.
    
    ```tsx
    type AorB = "A" | "B"; // 가능
    // interface AorB = "A" | "B"; // 불가능
    ```
    
2. 확장 방법
    
    ```tsx
    // interface로 type 확장
    interface IStateWithPop extends TState {
    	population: number;
    }
    
    // type으로 interface 확장
    type TStateWithPop = IState & { population: number; };
    ```
    
3. 튜플과 배열 타입
    - type이 더 간결하게 표현할 수 있다.
    
    ```tsx
    type Pair = [number, number];
    type StringList = string[];
    ```
    
    - interface도 튜플과 비슷하게 구현할 수 있기는 하지만, 튜플에서 사용할 수 있는 concat과 같은 메서드를 사용할 수 없다.
    - 따라서 튜플은 type으로 구현하는 것이 낫다.
4. 선언 병합 (Declaration Merging)
    - interface의 가장 큰 특징은 선언 병합이 가능하다는 것이다. (⇒ 보강(augment)한다고 한다.)
    
    ```tsx
    interface IState {
        name: string;
        capital: string;
    }
    
    // 같은 이름으로 새로운 필드 추가 가능
    interface IState {
        population: number;
    }
    
    // 결과적으로 IState는 name, capital, population 모두 가지게 됨
    ```
    

## 정리

- type을 사용하면 좋은 경우
    - 유니온 타입이 필요할 때
    - 튜플이나 배열 타입을 간단히 표현하고 싶을 때
    - 복잡한 타입을 정의할 때
    - 프로젝트 내부용 타입을 정의할 때
- interface를 사용하면 좋은 경우
    - 선언 병합이 필요한 경우
    - API 타입 선언을 작성할 때 (나중에 확장될 수 있기 때문)
    - 객체의 구조를 정의할 때
    - 다른 개발자들이 확장할 수 있어야 하는 타입을 정의할 때

# Item 14: 타입 연산과 제너릭 사용으로 반복 줄이기

> DRY(Don’t Repeat Yourself) 원칙
: 같은 내용을 반복하지 말라
> 

타입스크립트에도 코드의 DRY 원칙을 적용하는 것이 중요하다. 타입 정의에서의 중복을 제거하는 여러 방법은 아래와 같다.

## 기본적인 타입 중복 제거 방법

- 타입에 이름 붙이기:
    - `{ x: number; y: number }` 라는 구조가 두 번 반복되기 때문에 구조에 이름을 붙여 중복을 제거한다.
    
    ```tsx
    // 중복이 있는 코드
    function distance(a: { x: number; y: number }, b: { x: number; y: number }) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }
    
    // 개선된 코드
    interface Point2D {
        x: number;
        y: number;
    }
    
    function distance(a: Point2D, b: Point2D) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }
    ```
    
- 함수 시그니처 타입 분리:
    
    ```tsx
    // 타입 시그니처 분리
    type HTTPFunction = (url: string, opts: Options) => Promise<Response>;
    
    const get: HTTPFunction = (url, opts) => { /* ... */ };
    const post: HTTPFunction = (url, opts) => { /* ... */ };
    ```
    

## 타입 확장을 통한 중복 제거

- extends 사용:
    - extends를 사용하여 한 인터페이스는 다른 인터페이스를 확장하여 모든 속성을 자동으로 포함하며, 추가적인 속성만 정의하면 된다.
    
    ```tsx
    interface Person {
        firstName: string;
        lastName: string;
    }
    
    interface PersonWithBirthDate extends Person {
        birth: Date;
    }
    ```
    
- 인터섹션 타입 (&) 사용:
    
    ```tsx
    type PersonWithBirthDate = Person & { birth: Date };
    ```
    
    - 이 기법은 일반적이진 않지만 유니온 타입(확장할 수 없는)에 속성을 추가하려고 할 때 특히 유용하다.

## 타입 속성 인덱싱

- 인덱싱을 통한 타입 재사용:
    - State를 인덱싱하여 속성의 타입에서 중복을 제거할 수 있다.
    - 상단 네비게이션에 필요한 상태만 표현하는 TopNavState를 만들어야 한다면, State의 특정 속성들만 필요하다.
    - 자바스크립트에서 객체의 속성에 접근하는 것처럼 State의 특정 속성의 타입을 가져오는 것이다.
    
    ```tsx
    interface State {
        userId: string;
        pageTitle: string;
        recentFiles: string[];
        pageContents: string;
    }
    
    // 기존 타입에서 필요한 필드만 가져오기
    interface TopNavState {
        userId: State['userId'];
        pageTitle: State['pageTitle'];
        recentFiles: State['recentFiles'];
    }
    ```
    
- 매핑된 타입 사용:
    - 인덱싱을 통한 타입 재사용 기법으로 중복을 제거한 코드에서 여전히 반복되는 코드를 매핑된 타입으로 더욱 개선할 수 있다.
    - 객체의 속성을 순회하는 것처럼 지정된 속성들에 대해 State의 해당 타입을 가져온다.
    
    ```tsx
    // 더 간단한 방법
    type TopNavState = {
        [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k];
    };
    ```
    

## 표준 라이브러리의 제너릭 타입

- Pick:
    - Pick은 제너릭 타입으로 Pick을 사용하는 것은 함수를 호출하는 것과 같다.
    - 함수가 매개변수 값을 받아서 결괏값을 반환하는 것처럼, Pick은 T와 K 두 가지 타입을 받아 새로운 타입을 만들어낸다.
    
    ```tsx
    type TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>;
    
    // 결과적으로 다음과 같은 타입이 된다:
    // {
    //     userId: string;
    //     pageTitle: string;
    //     recentFiles: string[];
    // }
    ```
    
- Partial:
    - 타입의 모든 속성을 선택적(optional)으로 만든다.
    - 업데이트 함수를 만들 때 유용하다.
    
    ```tsx
    interface Options {
        width: number;
        height: number;
        color: string;
        label: string;
    }
    
    // 모든 필드가 선택적인 타입 생성
    type OptionsUpdate = Partial<Options>;
    
    // 결과적으로 다음과 같은 타입이 된다:
    // {
    //    width?: number;    // 선택적
    //    height?: number;   // 선택적
    //    color?: string;    // 선택적
    //    label?: string;    // 선택적
    // }
    ```
    
- ReturnType:
    - 함수의 반환 타입을 추출한다.
    - 복잡한 함수의 반환 타입을 별도로 사용하고 싶을 때 유용하다.
    
    ```tsx
    function getUserInfo(userId: string) {
        return { userId, name, age, height, weight };
    }
    
    type UserInfo = ReturnType<typeof getUserInfo>;
    ```
    

## 제너릭을 통한 타입 재사용

- 기본 제너릭 사용:
    
    ```tsx
    interface Name {
        first: string;
        last: string;
    }
    
    type DancingDuo<T extends Name> = [T, T];  // T는 반드시 Name의 모든 속성을 가져야 함
    
    const couple1: DancingDuo<Name> = [
        { first: 'Fred', last: 'Astaire' },
        { first: 'Ginger', last: 'Rogers' }
    ];     // 정상
    const couple2: DancingDuo<{first: string} = [   
    											 // ~~~~~~~~~~~~~~~
    											 // 'Name' 타입에 필요한 'last' 속성이
    											 // '{ first: string; }' 타입에 없습니다.
    		{ first: 'Sonny'},
    		{ first: 'Cher'},
    ];
    ```
    
- extends를 통한 제약 설정:
    - 위 예시에서 {first: string}은 Name을 확장하지 않기 때문에 오류가 발생한다.
    - extends를 사용하여 제너릭 타입의 제약 조건을 설정할 수 있다.
- `Pick` 유틸리티 타입의 실제 구현
    
    ```tsx
    // Pick 유틸리티 타입의 실제 구현
    type Pick<T, K extends keyof T> = {
        [k in K]: T[k];
    };
    ```
    
    - `T`: 원본 타입
    - `K extends keyof T`: K는 T의 키들의 부분집합이어야 함
    - `[k in K]` : K에 포함된 각 키에 대해
    - `T[k]` : 원본 타입 T에서 해당 키의 타입을 가져옴

# Item 15: 동적 데이터에 인덱스 시그니처 사용하기

## 동적 데이터를 다루는 인덱스 시그니처

- 자바스크립트에서는 객체를 손쉽게 생성하고 속성을 동적으로 추가/삭제 가능:
    
    ```jsx
    const rocket = {
    	name: 'Falcon 9',
    	variant: 'Block 5',
    	thrust: '7,607 kN',
    };
    ```
    
- 하지만 타입스크립트는 데이터 구조의 안전성을 보장하기 위해 동적 데이터도 타입을 명시적으로 정의해야 함

### 인덱스 시그니처

- 정의: 키와 값의 타입을 동적으로 정의하는 문법
    
    ```tsx
    type Rocket = {[property: string]: string};
    const rocket: Rocket = {
    	name: 'Falcon 9',
    	variant: 'v1.0',
    	thrust: '4,940 kN',
    };
    ```
    
    - **구조 :** `[property: string]: string`
        - 키 타입: string,number,symbol 중 하나
        - 값 타입: 어떤 것이든 가능. 위 구조에서는 string
    - **한계**:
        1. 잘못된 키 허용: 잘못된 키를 사용해도 타입 체크를 통과(name을 Name으로 작성한 것처럼)
        2. 특정 키가 필요하지 않음 (필수 키 없음): { } 도 유효한 Rocket 타입
        3. 키마다 다른 타입 지정 불가: thrust는 string이 아니라 number 여야 할 수도 있음
        4. 타입스크립트 언어 서비스의 자동 완성 기능이 동작하지 않음
    

## 대안: 구체적인 타입 사용

- 인덱스 시그니처 대신 명확한 구조를 가진 **interface**를 정의
    
    ```tsx
    interface Rocket {
    	name: string;
    	variant: string;
    	thrust_kN: number;
    }
    const falconHeavy: Rocket = {
    	name: 'Falcon Heavy',
    	variant: 'v1',
    	thrust_kN: 15_200
    };
    ```
    
- 장점:
    - 필수 필드 확인: 모든 속성이 정확히 정의되었는지 확인 가능
    - 타입스크립트 언어 서비스 지원: 자동완성, 이름 바꾸기 등 가능

## 인덱스 시그니처의 사용

- 동적인 키-값 쌍을 다룰 때 사용
- **예제: CSV 데이터 파싱** (열 이름이 동적으로 결정되는 경우)
    
    ```tsx
    function parseCSV(input: string): {[columnName: string]: string}[] {
      const lines = input.split('\n');
      const [headerLine, ...rows] = lines; // 헤더와 데이터 분리
      const headers = headerLine.split(',');
      return rows.map(rowStr => {
        const row: {[columnName: string]: string} = {}; // 빈 객체 생성. 인덱스 시그니처를 사용해서 동적 키-값 쌍을 저장할 수 있게 함
        rowStr.split(',').forEach((cell, i) => {
          row[headers[i]] = cell;   // headers[i]는 현재 셀에 해당하는 열 제목, cell은 현재 셀의 값
    													      // 헤더와 값을 매핑하여 객체에 키-값 쌍 추가
        });
        return row;
      });
    }
    ```
    
    - `parseCSV`  함수는 CSV 데이터를 받아, 각 행을 열 이름과 매핑된 객체로 변환
    - 열 이름(헤더)이 고정되어 있지 않으므로 인덱스 시그니처 활용 
    (`{[columnName: string]: string}` )
        - 열 이름(columnName)을 키로, 해당 셀의 값을 값으로 가짐

## 열 이름을 알고 있을 때의 타입 지정

- 미리 선언된 타입과 **타입 단언 (Type Assertion)** 사용**:**
    
    ```tsx
    // 구체적인 타입 정의
    interface ProductRow {
      productId: string;
      name: string;
      price: string;
    }
    
    declare let csvData: string;
    // 타입 단언 사용
    const products = parseCSV(csvData) as unknown[] as ProductRow[];
    ```
    
- `parseCSV` 함수의 반환타입은 `{[columnName: string]: string}[]`
    
    : 어떤 문자열 키든 가질 수 있고, 그 값도 문자열인 객체들의 배열을 의미
    
- **열 이름이 고정된 상황**(열 이름을 알고 있는 특정한 상황)에서는 더 구체적인 타입으로 데이터를 다루고 싶을 수 있음
- 컴파일러에게 데이터가 `ProductRow[]`와 일치한다고 강제로 알리는 것
- 자동완성 기능을 사용할 수 있고 잘못된 열 이름 사용시 컴파일 오류가 발생함

## 더 안전한 처리가 필요할 때

- 타입 단언만으로는 데이터가 실제로 구조를 따르는지 보장할 수 없음
- **해결 방법:** `undefined` 를 포함한 타입으로 안전성 강화
    
    ```tsx
    function safeParseCSV(
    	input: string
    ): {[columnName: string]: string | undefined)[] }
    	return parseCSV(input);
    }
    ```
    
- 안전성을 위한 코드 개선 예제:
    
    ```tsx
    const rows = parseCSV(csvData);
    const prices: {[product: string]: number} = {};
    for (const row of rows) {
    	prices[row.productId] = Number(row.price);
    	// 오류 발생 가능: row.productId 또는 row.price가 undefined일 수 있음
    }
    
    const safeRows = safeParseCSV(csvData);
    for (const row of safeRows) {
    	prices[row.productId] = Number(row.price);
    		// ~~~~~~~~~~~~~ 'undefined' 형식을 인덱스 형식으로 사용할 수 없습니다.
    }
    
    ```
    

## 인덱스 시그니처의 대안

1. **Record 사용**
    - Record: 키 타입에 유연성을 제공하는 제너릭 타입으로, string의 부분 집합을 사용할 수 있음
    - 아래 코드 예시에서 키를 `'x'` , `'y'` ,`'z'` 로 제한하면서 값을 `number`로 지정
    
    ```tsx
    type Vec3D = Record<'x' | 'y' | 'z', number>;
    //   Type Vec3D = {
    //        x: number;
    //        y: number;
    //        z: number;
    //      }
    ```
    
2. **매핑된 타입 사용**
    - 매핑된 타입은 키마다 별도의 타입을 사용하게 해줌
    - 아래 코드 예시에서 `k` 는 `‘x’`, `'y'` , `'z'` 중 하나이며 값은 `number`
    
    ```tsx
    type Vec3D = {[k in 'x' | 'y' | 'z']: number};
    // Type Vec3D = {
    //    x: number;
    //    y: number;
    //    z: number;
    //}
    ```
    
    - `'a'` ,`'c'` 의 값은 `number` , `'b'` 의 값은 `string`
    
    ```tsx
    type ABC = {[k in 'a' | 'b' | 'c']: k extends 'b' ? string : number};
    // Type Vec3D = {
    //    a: number;
    //    b: string;
    //    c: number;
    //}
    ```
    
3. **유니온 타입 사용**
    - 여러 가지 조합 가능한 키를 명확히 모델링:
    
    ```tsx
    type Row =
      | { a: number }
      | { a: number; b: number }
      | { a: number; b: number; c: number }
      | { a: number; b: number; c: number; d: number };
    ```
    
4. **Map 타입 사용**
    - 동적 키를 다룰 때, 객체 대신 `Map` 을 사용하는 것을 고려:
    
    ```tsx
    const prices = new Map<string, number>();
    prices.set('product1', 100);
    prices.set('product2', 200);
    ```
    

# Item 16: number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

## 자바스크립트의 배열과 객체

- 자바스크립트에서 객체의 키는 항상 string이거나 symbol
- 숫자 키를 사용해도 자바스크립트는 이를 문자열로 변환
    
    ```tsx
    const obj = { 1: "value1", 2: "value2" };
    console.log(obj); // { '1': 'value1', '2': 'value2' }
    ```
    
- 배열도 객체이기 때문에 숫자 키를 사용해 접근할 수 있지만, 내부적으로는 문자열로 처리됨
    
    ```tsx
    const arr = [1, 2, 3];
    console.log(arr[0]);   // 1
    console.log(arr["1"]); // 2
    ```
    
- `Object.keys`로 배열의 키를 출력해보면 문자열로 나타남
    
    ```tsx
    const arr = [1, 2, 3];
    console.log(Object.keys(arr)); // ['0', '1', '2']
    ```
    
- **타입스크립트의 개선**
    - 타입스크립트는 숫자 키를 명시적으로 허용하여 런타임 오류를 방지
    - 배열의 타입 선언:
        
        ```tsx
        interface Array<T> {
          [n: number]: T; // 인덱스 시그니처로 숫자 키 선언
        }
        ```
        

## number 인덱스 시그니처의 한계

- **런타임 동작과의 불일치**
    - 런타임에는 모든 키가 문자열로 변환됨
    - 숫자 키는 컴파일 시에는 `number` 로 정의되지만, 런타임에서는 문자열로 동작
        
        ```tsx
        const xs = [1, 2, 3];
        const x = xs["1"]; // 컴파일 오류: 문자열로 접근할 수 없음
        ```
        
- **기존 코드를 사용할 때 혼란**
    - 타입 체크 할 때와 실제 동작이 다름
    - `Object.keys`로 가져온 키는 `string[]` 타입이지만 배열 요소는 `number` 타입으로 접근해야 함
        
        ```tsx
        const keys = Object.keys(xs); // string[]
        const firstKey = keys[0]; // 타입은 string
        const value = xs[firstKey]; // 컴파일 오류: string으로 인덱스할 수 없음
        ```
        

## 배열 순회와 접근 방법

1. **for-of 루프 사용 (추천):**
    - 배열의 값을 순회할 때는 **for-of**를 사용하는 것이 가장 안전하고 간단
    
    ```tsx
    for (const x of xs) {
      console.log(x); // 타입은 number
    }
    ```
    
2. **forEach 메소드 사용:**
    - 배열의 인덱스와 값을 동시에 사용할 때 적합
    
    ```tsx
    xs.forEach((value, index) => {
      console.log(index, value); // index: number, value: number
    });
    ```
    
3. **C 스타일 루프 사용:**
    - 루프 중간에 멈춰야 할 때 사용
    
    ```tsx
    for (let i = 0; i < xs.length; i++) {
      if (xs[i] < 0) break;
    }
    ```
    
4. **for-in 루프는 비추천:**
    - for-in은 배열 순회에 적합하지 않으며 성능도 저하됨

## 대안: Array, 튜플, ArrayLike 사용

- **Array 타입**
    - 배열을 나타낼 때 가장 일반적으로 사용하는 타입
    - 타입 안전성을 보장받을 수 있고 배열 메서드 사용 가능
    
    ```tsx
    const xs: number[] = [1, 2, 3];
    xs.push(4); // 정상
    ```
    
- **튜플 타입**
    - 길이와 요소 타입이 고정된 배열을 나타냄
    - 각 위치의 타입이 명확하고 길이가 고정됨
    
    ```tsx
    const tuple: [number, string, boolean] = [42, "hello", true];
    ```
    
- **ArrayLike 타입**
    - 배열처럼 동작하지만, 실제로는 객체로 나타나는 데이터 구조에 사용
    - 배열과 비슷하지만 배열 메서드가 없음
    - 배열처럼 인덱스로 접근하고 길이를 알 수 있지만 배열 메서드는 필요 없을 때 사용
    
    ```tsx
    function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
      if (i < xs.length) {
        return xs[i];
      }
      throw new Error(`배열 끝을 넘어 ${i}를 접근했습니다.`);
    }
    
    const tupleLike: ArrayLike<string> = {
      "0": "A",
      "1": "B",
      length: 2,
    };
    console.log(checkedAccess(tupleLike, 1)); // B
    
    ```
    

# Item 17: 변경 관련된 오류 방지를 위해 readonly 사용하기

- **`readonly` 란?**
    - `readonly`는 타입스크립트에서 값을 읽을 수만 있고 수정할 수 없도록 만드는 타입스크립트 키워드
    - 코드에서 예상치 못한 변경을 방지하고, 오류를 줄이며 코드의 안전성을 높일 수 있음

## **문제 상황: 변경으로 인한 오류**

- **삼각수(Triangular Number)를 계산하는 코드 예시:**
    
    ```tsx
    function printTriangles(n: number) {
      const nums = [];
      for (let i = 0; i < n; i++) {
        nums.push(i);
        console.log(arraySum(nums)); // 문제 발생!
      }
    }
    
    function arraySum(arr: number[]) {
      let sum = 0, num;
      while ((num = arr.pop()) !== undefined) {
        sum += num; // 배열의 원소를 변경하며 합산
      }
      return sum;
    }
    
    ```
    
- **문제:** `arraySum` 함수는 전달받은 배열을 변경(pop으로 제거)하면서 합을 계산
    - 배열이 비워지므로 원래 배열 상태를 유지하지 못함
- **결과:** 예상과 다른 출력이 발생:
    
    ```tsx
    0
    1
    2
    3
    4
    ```
    

## **`readonly`로 문제 해결**

- **`readonly`를 사용하여 배열 변경 방지:**
    
    ```tsx
    function arraySum(arr: readonly number[]) {
      let sum = 0, num;
      while ((num = arr.pop()) !== undefined) {
        // 오류: readonly 배열은 pop 메서드를 사용할 수 없습니다.
        sum += num;
      }
      return sum;
    }
    ```
    
- `readonly`를 추가하면 배열의 요소를 읽을 수만 있고, **pop, push, slice**와 같은 메서드를 호출할 수 없음
- 배열의 길이(`length`)를 읽을 수는 있지만 변경할 수는 없음
- 올바른 코드:
    
    ```tsx
    function arraySum(arr: readonly number[]) {
      let sum = 0;
      for (const num of arr) {
        sum += num; // 배열을 변경하지 않고 합산
      }
      return sum;
    }
    ```
    
    결과:
    
    ```tsx
    0
    1
    3
    6
    10
    ```
    

## **`readonly` 배열의 특징**

- **읽기만 가능:**
    - 배열의 값을 읽을 수 있지만, 변경할 수는 없음
- **`readonly`는 제한적 기능 제공:**
    - `number[]` 는 `readonly number[]` 보다 기능이 많음
    - `readonly number[]`의 서브타입이 됨
    - 즉, 변경 가능한 배열(`number[]`)을 읽기 전용 배열(`readonly number[]`)에 할당할 수 있음
    - 반대로 **읽기 전용 배열을 변경 가능한 배열로 할당**할 수는 없음
        
        ```tsx
        const a: number[] = [1, 2, 3];
        const b: readonly number[] = a; // 정상
        const c: number[] = b; // 오류: readonly를 변경 가능한 배열로 할당 불가
        ```
        
- **매개변수로 사용하면** 함수가 매개변수를 변경하지 않을 것을 보장
    
    ```tsx
    function processArray(arr: readonly number[]) {
      // arr.push(1); // 오류: readonly 배열은 push 사용 불가
      for (const num of arr) {
        console.log(num);
      }
    }
    
    ```
    
- 필요한 경우, `readonly` 배열을 타입 단언을 사용해 변경 가능 배열로 변환
    
    ```tsx
    const readonlyArr: readonly number[] = [1, 2, 3];
    const writableArr = readonlyArr as number[];
    writableArr.push(4); // 가능
    ```
    

## **`readonly`의 장점**

- **코드 안전성 향상:**
    - 전달받은 배열이 함수 내부에서 변경되지 않음을 보장
    - 호출하는 쪽에서도 함수가 매개변수를 변경하지 않는다는 확신을 가질 수 있음
- **변경 방지 오류 확인:**
    - 타입스크립트는 변경을 시도하는 코드를 컴파일 오류로 잡아냄
- **타입 확장 가능:**
    - `readonly` 타입은 더 넓은 타입과 호환됨
    - 예를 들어, `readonly number[]` 타입은 `number[]` 타입으로 동작하는 함수에 전달 가능

## 다른 활용 사례

- 객체에도 `readonly`를 적용할 수 있음
- `readonly` 는 얕게 동작하여 첫번째 레벨의 속성만 읽기 전용으로 만듦
    
    ```tsx
    interface Outer {
      inner: { x: number };
    }
    const obj: Readonly<Outer> = { inner: { x: 0 } };
    
    obj.inner = { x: 1 }; // 오류: 'inner'는 읽기 전용입니다.
    obj.inner.x = 1; // 정상: readonly는 얕게 동작. 중첩된 객체의 속성은 수정 가능
    ```
    
- 전체 객체, 즉 객체의 모든 속성을 읽기 전용으로 변경
    
    ```tsx
    interface User {
      name: string;
      age: number;
    }
    
    const user: Readonly<User> = { name: "Alice", age: 30 };
    user.age = 31; // 오류: 'age'는 읽기 전용입니다.
    ```
    
- 인덱스 시그니처에서의 `readonly`
    
    ```tsx
    const obj: { readonly [key: string]: number } = { a: 1, b: 2 };
    obj.a = 3; // 오류: 'a'는 읽기 전용입니다.
    ```
    

## **`readonly`의 한계**

- **얕게 동작:**
    - `readonly`는 얕은 복사(Shallow Copy)만 보장
    - 중첩된 객체는 여전히 수정 가능
        
        ```tsx
        const obj: Readonly<{ inner: { x: number } }> = { inner: { x: 0 } };
        obj.inner.x = 1; // 정상
        ```
        
- **깊은 읽기 전용:**
    - 타입스크립트 기본으로는 지원하지 않지만, 제너릭이나 라이브러리를 사용하면 구현 가능:
    
    ```tsx
    type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };
    ```
    

# Item 18: 매핑된 타입을 사용하여 값을 동기화하기

## 문제 상황

- React와 같은 UI 라이브러리에서 컴포넌트의 최적화는 매우 중요한 작업.
- 컴포넌트의 불필요한 렌더링을 방지하기 위해, 값이 변경된 경우에만 다시 렌더링해야 함

- 아래는 산점도(ScatterPlot) 컴포넌트를 위한 Props 타입:
    
    ```tsx
    interface ScatterProps {
      // Data
      xs: number[];
      ys: number[];
    
      // Display
      xRange: [number, number];
      yRange: [number, number];
      color: string;
    
      // Event
      onClick: (x: number, y: number, index: number) => void;
    }
    ```
    
    - 데이터와 디스플레이 속성이 변경되면 재 렌더링
    - 하지만 이벤트핸들러가 변경되더라도 차트를 다시 렌더링할 필요는 없음

→ 이를 최적화하기 위해 렌더링 여부를 결정하는 `shouldUpdate` 함수를 작성할 수 있음

## 실패에 닫힌 접근법 (보수적 접근법)

```tsx
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps): boolean {
  let k: keyof ScatterProps;
  for (k in oldProps) {
    if (oldProps[k] !== newProps[k]) {
      if (k !== "onClick") return true; // onClick 변경은 무시
    }
  }
  return false;
}
```

- 모든 속성을 확인하며, `onClick` 속성의 변경은 무시
- 보수적(conservative) 접근법: 모든 변경 사항을 신중히 처리
    - 장점: 렌더링이 누락되지 않음
    - 단점: 렌더링이 불필요하게 자주 발생할 수 있음

## 실패에 열린 접근법

```tsx
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps): boolean {
  return (
    oldProps.xs !== newProps.xs ||
    oldProps.ys !== newProps.ys ||
    oldProps.xRange !== newProps.xRange ||
    oldProps.yRange !== newProps.yRange ||
    oldProps.color !== newProps.color
  );
}
```

- 필요한 속성만 확인하며, 나머지 속성의 변경은 무시
- 실패에 열린(fail-open) 접근법: 속성을 특정하여 최소한의 변경만 처리
    - 장점: 불필요한 렌더링을 줄임
    - 단점: 새로운 속성이 추가되면 이를 놓칠 가능성이 있음

## **매핑된 타입을 활용한 개선된 접근법**

**매핑된 타입**을 사용하여 속성별로 렌더링 필요 여부를 관리

1. **매핑된 타입 객체 정의:**
    
    ```tsx
    const REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {
      xs: true,
      ys: true,
      xRange: true,
      yRange: true,
      color: true,
      onClick: false, // 이벤트 핸들러는 렌더링에 영향을 주지 않음
    };
    ```
    
    - `[k in keyof ScatterProps]`: `ScatterProps`와 동일한 속성을 가진 객체를 정의
    - 새로운 속성이 추가되면 **타입 체커가 REQUIRES_UPDATE 객체에도 추가를 요구**

1. `shouldUpdate` 함수:
    
    ```tsx
    function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps): boolean {
      let k: keyof ScatterProps;
      for (k in oldProps) {
        if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) {
          return true;
        }
      }
      return false;
    }
    
    ```
    
    - `REQUIRES_UPDATE[k]`가 `true`인 속성만 비교
    - 새로운 속성이 추가되었을 때 자동으로 타입 체크가 작동

## **매핑된 타입 활용의 장점**

- **타입 안정성 확보:**
    - 매핑된 타입(`[k in keyof ScatterProps]`)은 `ScatterProps`와 동일한 속성을 가져야 하므로, 새로운 속성이 추가되었을 때 타입 체커가 이를 알림
- **가독성과 유지보수성 증가:**
    - 렌더링 여부를 결정하는 논리를 한 곳에 모아 관리할 수 있음
- **유연한 렌더링 제어:**
    - `REQUIRES_UPDATE`를 수정하여 속성별 렌더링 여부를 쉽게 조정할 수 있음

## **매핑된 타입 객체 사용 시 주의점**

- **값과 타입의 구분:**
    - `REQUIRES_UPDATE`는 **타입 객체**가 아니라 실제 **값** 객체
    - 즉, `boolean` 값을 가지며, 타입 검증을 위해 존재
- **속성 추가 시 타입 체커에 의존:**
    - 새로운 속성이 `ScatterProps`에 추가되면, 반드시 `REQUIRES_UPDATE`에도 추가해야 함
    - 추가하지 않으면 타입스크립트가 이를 감지하여 오류를 발생시킴
