<!-- 107-154 -->

# 3장 타입 추론

## 아이템 19 - 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 타입스크립트는 타입 추론을 적극적으로 수행하기 때문에 수동 타입 명시는 엄청나게 줄어든다. 따라서 모든 변수에 타입을 선언하는 것은 불필요하며 비생산적인 행동이다.

```ts
// Bad
const person: {
  name: string;
  born: {
    where: string;
    when: string;
  };
} = {
  name: "yhan",
  born: {
    where: "Busan, South Korea",
    when: "25, 12, 1993",
  },
};

// Good
const person = {
  name: "yhan",
  born: {
    where: "Busan, South Korea",
    when: "25, 12, 1993",
  },
};
```

- 타입 선언이 불필요한 경우

  1. 객체나 배열의 경우에는 타입 작성이 필요하지 않다.
  2. 함수 및 메서드 내부에서 생성된 지역변수에는 타입구문이 필요하지 않다.
  3. 비구조화 할당은 타입 추론이 가능해서 타입 구문이 필요하지 않다.

- 타입 선언이 필요한 경우

  1. 객체 리터럴을 정의할 때는 타입을 명시해주면 오타 등의 오류를 잡는데 유용하다.
  2. 함수 반환값은 타입 구문을 통해 타입을 선언한다.

## 아이템 20 - 다른 타입에는 다른 변수 사용하기

- 자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 되지만, 타입스크립트에서는 오류가 발생한다.

```ts
// JS
let id = "12-34-56";
fetchProduct(id); //string으로 사용
id = 123456;
fetchProductBySeriaNumber(id); //number로 사용

// TS
let id = "12-34-56";
fetchProduct(id);
id = 123456;
// 에러: ~~ '123456' 형식은 'string' 형식에 할당할 수 없습니다.
fetchProductBySeriaNumber(id);
// 에러: ~~ 'string' 형식의 인수는 'number' 형식의 매개변수에 할당될 수 없습니다.
```

- 변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다.

#### 변수 재사용 시 여러 타입 문제 해결

- 유니온 타입
- 별도의 변수에 할당

```ts
// 유니온 타입
// Bad
let id: string | number = "12-34-56";
fetchProduct(id);

id = 123456;
fetchProductBySerialNumber(id);

// 별도의 변수에 할당
// Good
const id = "12-34-56";
fetchProduct(id);

const serial = 123456;
fetchProductBySerialNumber(serial);
```

- 별도의 변수에 할당하는 겻의 장점

  - 서로 관련이 없는 두 개의 값을 분리한다. (id와 serial)
  - 변수명을 더 구체적으로 지을 수 있다.
  - 타입 추론을 향상시키고, 타입 구분이 불필요해진다.
  - 타입이 좀 더 간결해진다. (string | number 대신 string과 number를 사용).
  - let 대신 const 사용하면 코드가 간결해지고 타입 체커가 타입 추론을 하기에도 좋다.

#### 가려지는(shadowed) 변수

```ts
const id = "12-34-56";
fetchProduct(id);
{
  const id = 123456; // 정상
  fetchProductBySerialNumber(id); //정상
}
```

- 이름이 같아도 동작에는 문제가 없지만 개발자에게 혼란을 줄 수 있다. 따라서 별도의 변수명을 사용하는게 좋다.

## 아이템 21 - 타입 넓히기

- 런타임에 모든 변수는 유일한 값을 가진다.
- 컴파일타임에 타입스크립트에서 변수는 '가능한' 값들의 집합인 타입을 가진다.

- 상수를 사용해서 변수를 초기화하는 경우 타입을 명시하지 않으면 타입 체커는 타입을 결정해야한다. 지정된 단일 값을 이용해서 할당 가능한 값들의 집합을 유추해야 한다는 뜻이다. 타입스크립트에서 이러한 과정을 넓히기(widening) 이라 한다.

- 타입 넓히기 때문에 실행이 되지만 컴파일 오류가 발행하는 경우도 있다.

- 타입스크립트는 명확성과 유연성 사이에서 균형을 유지하며 추론하려고 한다.

- 변수가 선언된 후로는 타입이 바뀌지 않아야 하므로, 일반적으로 할당 시점에 추론을 한다.

#### 넓히기 과정 제어

- let 대신 const를 사용하면 더 좁은 타입으로 타입을 좁힌다. 하지만 객체 배열의 경우 여전히 문제가 발생한다.
- 객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let 으로 할당된 것처럼 다룬다.

- 타입스크립트 기본 동작 재정의 방법

  1. 명시적 타입 구문 제공

  ```ts
  const v: { x: 1 | 3 | 5 } = {
    x: 1,
  }; // 타입: { x: 1|3|5; }
  ```

  2. 타입 체커에 추가적인 문맥을 제공

  3. const 단언문을 사용 (타입 공간의 기법. 변수 선언과 혼동하지 말것)

  ```ts
  const v1 = {
    x: 1,
    y: 2,
  }; // 타입: { x: number; y: number; }

  const v2 = {
    x: 1 as const,
    y: 2,
  }; // 타입: { x: 1; y: number; }

  const v3 = {
    x: 1,
    y: 2,
  } as const; // 타입: { readonly x: 1; readonly y: 2; }

  // 배열도 사용 가능하다.
  const a1 = [1, 2, 3]; // 타입: nunmber[]
  const a2 = [1, 2, 3] as const; // 타입: readonly [1, 2, 3]
  ```

## 아이템 22 - 타입 좁히기

- 타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정이다.

- 타입 좁히기의 가장 일반적인 예시로 DOM요소를 가져와 null인지 체크하는 과정이 있다.

- 타입을 좁히는 방법
  - 조건문, 분기문
  - instanceof
  - Array.isArray와 같은 내장 함수
  - 명시적 ‘태그' (태그된 유니온, 구별된 유니온)
  - 사용자 정의 타입 가드

## 아이템 23 - 한꺼번에 객체 생성하기

## 아이템 24 - 일관성 있는 별칭 사용하기

## 아이템 25 - 비동기 코드에는 콜백 대신 async 함수 사용하기

## 아이템 26 - 타입 추론에 문맥이 어떻게 사용되는지 이해하기

## 아이템 27 - 함수형 기법과 라이브러리로 타입 흐름 유지하기
