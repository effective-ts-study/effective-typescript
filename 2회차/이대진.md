# 2. 타입스크립트의 타입 시스템

### 2.12 함수 표현식에 타입 적용하기

TS에서는 함수 표현식을 사용하는 것이 좋음. 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있음.

매개변수나 반환 값에 타입을 명시하지 말고 함수 표현식 전체에 타입 구문을 적용하자.

```tsx
type DiceRollFn = (sides: number) => number;
const rollDice: DickRollFn = sides => { ... };
```

라이브러리에서 공통 콜백 함수를 위한 타입 선언을 제공하기도 한다.

### 2.13. 타입과 인터페이스의 차이점 알기

선언 방법은 차이가 거의 없다. type이 interface보다 쓰임새가 많다.
코드베이스에서 어떤 것을 일관적으로 사용중인지를 고려해서 사용하자.

인터페이스를 권장하는 추세로 보임.

### 2.14. 타입 연산과 제네릭 사용으로 반복 줄이기

타입 간 매핑을 위해 keyof, typeof, 인덱싱, 매핑된 타입 등을 공부하자.

타입을 위한 함수와 같은 제너릭 타입을 사용하자. 타입을 반복하는 대신 제너릭을 사용하여 타입 간 매핑을 하자. 이를 제한하려면 extends를 사용하자.

표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해지자.

### 2.15 동적 데이터에 인덱스 시그니처 사용하기

TS에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다. 다만 인덱스 시그니처는 여러 단점들이 존재하기 때문에, 런타임 때까지 객체의 속성을 모를 때만 인덱스 시그니처를 사용하자.

가능하다면 인터페이스, Record, 매핑된 타입 같은 정확한 타입을 인덱스보다 우선시 하는게 좋다.

### 2.16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용

인덱스 시그니처가 number여도 런타임에 사용되는 키는 string이다.
드물지만 필요하다면 ArrayLike를 사용하자. 하지만 그래도 키는 여전히 문자열이다.

### 2.17 변경 관련 오류 방지를 위해 readonly 사용하기

함수가 매개변수를 변경하지 않는다면 readonly로 선언하는 것이 좋다.
(다만 readonly는 얕게 동작하므로 freeze 같은 방법을 생각할 것)

### 2.18 매핑된 타입을 사용하여 값을 동기화하기

매핑된 타입을 사용하면 속성을 삭제하거나 이름을 바꾸어도 오류를 발생시킨다. 한 객체가 다른 객체와 정확히 다른 속성을 가지게 할 때 이상적이다.
